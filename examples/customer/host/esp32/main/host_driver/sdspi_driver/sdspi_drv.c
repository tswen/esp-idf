// Copyright 2015-2021 Espressif Systems (Shanghai) PTE LTD
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/** Includes **/
#include "string.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"

#include "trace.h"
#include "sdspi_drv.h"
#include "adapter.h"
#include "serial_drv.h"
#include "netdev_if.h"

#ifdef CONFIG_TRANSMIT_USE_SDSPI
#include "sdspi_host.h"
#include "port.h"
#else
#include "sdio_host_transport.h"
#include "host_serial_bus.h"
#include "host_config.h"
#endif

/** Constants/Macros **/
#define TO_SLAVE_QUEUE_SIZE               10
#define FROM_SLAVE_QUEUE_SIZE             10

#define PROCESS_RX_TASK_STACK_SIZE        4096

#define READ_BUFFER_LEN     4096

#define ESP_PAYLOAD_HEADER_SIZE    8
#define MAX_PAYLOAD_SIZE (MAX_SPI_BUFFER_SIZE-sizeof(struct esp_payload_header))

static const char *TAG = "sdio_drv";

#ifdef CONFIG_TRANSMIT_USE_SDSPI
static spi_context_t context;
static uint8_t esp_at_sendbuf[READ_BUFFER_LEN] = "";
static uint8_t esp_at_recvbuf[READ_BUFFER_LEN + 1] = "";
static void sdspi_recv_task(void* pvParameters);
#else
static host_serial_bus_handle_t s_host_device_handle;
static esp_err_t IRAM_ATTR recv_cb(host_serial_bus_handle_t device, host_recv_status_t recv_status, const void *buffer, size_t len);
#endif

static int esp_netdev_open(netdev_handle_t netdev);
static int esp_netdev_close(netdev_handle_t netdev);
static int esp_netdev_xmit(netdev_handle_t netdev, struct pbuf *net_buf);

static struct esp_private *esp_priv[MAX_NETWORK_INTERFACES];

static struct netdev_ops esp_net_ops = {
	.netdev_open = esp_netdev_open,
	.netdev_close = esp_netdev_close,
	.netdev_xmit = esp_netdev_xmit,
};

/** Exported variables **/
extern struct host_device_handle *esp_hosted_driver_handle;

// static osMutexId mutex_trans;
static SemaphoreHandle_t xSemaphore = NULL;
static SemaphoreHandle_t mutex_trans = NULL;

static TaskHandle_t Process_RX_Task_Handle = NULL;

/* Queue declaration */
static QueueHandle_t to_slave_queue = NULL;
static QueueHandle_t from_slave_queue = NULL;

/* callback of event handler */
static void (*sdspi_drv_evt_handler_fp) (uint8_t);

/** function declaration **/
/** Exported functions **/
static void process_rx_task(void* pvParameters);
static uint8_t * get_tx_buffer(uint8_t *is_valid_tx_buf);
static void deinit_netdev(void);

/**
  * @brief  get private interface of expected type and number
  * @param  if_type - interface type
  *         if_num - interface number
  * @retval interface handle if found, else NULL
  */
static struct esp_private * get_priv(uint8_t if_type, uint8_t if_num)
{
	for (int i = 0; i < MAX_NETWORK_INTERFACES; i++) {
		if((esp_priv[i]) &&
			(esp_priv[i]->if_type == if_type) &&
			(esp_priv[i]->if_num == if_num))
			return esp_priv[i];
	}

	return NULL;
}

/**
  * @brief  open virtual network device
  * @param  netdev - network device
  * @retval 0 on success
  */
static int esp_netdev_open(netdev_handle_t netdev)
{
	return ESP_OK;
}

/**
  * @brief  close virtual network device
  * @param  netdev - network device
  * @retval 0 on success
  */
static int esp_netdev_close(netdev_handle_t netdev)
{
	return ESP_OK;
}

/**
  * @brief  transmit on virtual network device
  * @param  netdev - network device
  *         net_buf - buffer to transmit
  * @retval None
  */
static int esp_netdev_xmit(netdev_handle_t netdev, struct pbuf *net_buf)
{
	struct esp_private *priv;
	int ret;

	if (!netdev || !net_buf)
		return ESP_FAIL;
	priv = (struct esp_private *) netdev_get_priv(netdev);

	if (!priv)
		return ESP_FAIL;

	ret = send_to_slave(priv->if_type, priv->if_num,
			net_buf->payload, net_buf->len);
	free(net_buf);

	return ret;
	return 0;
}

/**
  * @brief  create virtual network device
  * @param  None
  * @retval None
  */
static int init_netdev(void)
{
	void *ndev = NULL;
	int i = 0;
	struct esp_private *priv = NULL;
	char *if_name = STA_INTERFACE;
	uint8_t if_type = ESP_STA_IF;

	for (i = 0; i < MAX_NETWORK_INTERFACES; i++) {
		/* Alloc and init netdev */
		ndev = netdev_alloc(sizeof(struct esp_private), if_name);
		if (!ndev) {
			deinit_netdev();
			return ESP_FAIL;
		}

		priv = (struct esp_private *) netdev_get_priv(ndev);
		if (!priv) {
			deinit_netdev();
			return ESP_FAIL;
		}

		priv->netdev = ndev;
		priv->if_type = if_type;
		priv->if_num = 0;

		if (netdev_register(ndev, &esp_net_ops)) {
			deinit_netdev();
			return ESP_FAIL;
		}

		if_name = SOFTAP_INTERFACE;
		if_type = ESP_AP_IF;

		esp_priv[i] = priv;
	}

	return ESP_OK;
}

/**
  * @brief  destroy virtual network device
  * @param  None
  * @retval None
  */
static void deinit_netdev(void)
{
	for (int i = 0; i < MAX_NETWORK_INTERFACES; i++) {
		if (esp_priv[i]) {
			if (esp_priv[i]->netdev) {
				netdev_unregister(esp_priv[i]->netdev);
				netdev_free(esp_priv[i]->netdev);
			}
			esp_priv[i] = NULL;
		}
	}
}


/** function definition **/

/** Exported Functions **/
/**
  * @brief  spi driver initialize
  * @param  spi_drv_evt_handler - event handler of type spi_drv_events_e
  * @retval None
  */
esp_err_t esp_sdspi_init(void(*spi_drv_evt_handler)(uint8_t))
{
	esp_err_t retval = ESP_OK;

#ifdef CONFIG_TRANSMIT_USE_SDSPI
    retval = at_sdspi_init();
    assert(retval == ESP_OK);
	memset(&context, 0x0, sizeof(spi_context_t));
	at_sdspi_send_intr(0);
#else
	s_host_device_handle = host_serial_bus_open(DEVICE_SDIO);
	if (s_host_device_handle == NULL) {
		ESP_LOGE(TAG, "open device error");
		return ESP_FAIL;
	}
	sdio_host_send_intr(0);
	host_serial_bus_register_recv_callback(s_host_device_handle, recv_cb);
#endif

	/* register callback */
	sdspi_drv_evt_handler_fp = spi_drv_evt_handler;

	retval = init_netdev();
	if (retval) {
		printf("netdev failed to init\n\r");
		assert(retval==ESP_OK);
	}

	/* Queue - tx */
	to_slave_queue = xQueueCreate(TO_SLAVE_QUEUE_SIZE,
			sizeof(interface_buffer_handle_t));
	assert(to_slave_queue);

	/* Queue - rx */
	from_slave_queue = xQueueCreate(FROM_SLAVE_QUEUE_SIZE,
			sizeof(interface_buffer_handle_t));
	assert(from_slave_queue);

	/* Task - RX processing */
#ifdef CONFIG_TRANSMIT_USE_SDSPI
	xTaskCreate(sdspi_recv_task, "sdspi_recv_task", 4 * 1024, NULL, 6, NULL);
#endif
	xTaskCreate(process_rx_task, "Process_RX_Task", PROCESS_RX_TASK_STACK_SIZE, NULL, 6, &Process_RX_Task_Handle);
	configASSERT(Process_RX_Task_Handle);

	return ESP_OK;
}


static void check_and_execute_spi_transaction(uint16_t wlen)
{
	uint8_t * txbuff = NULL;
	uint8_t is_valid_tx_buf = 0;

	/* Get next tx buffer to be sent */
	txbuff = get_tx_buffer(&is_valid_tx_buf);
	// ESP_LOG_BUFFER_HEXDUMP(TAG, txbuff, wlen + ESP_PAYLOAD_HEADER_SIZE, ESP_LOG_INFO);

#ifdef CONFIG_TRANSMIT_USE_SDSPI
	esp_err_t err = at_sdspi_send_packet(&context, txbuff, wlen + ESP_PAYLOAD_HEADER_SIZE, UINT32_MAX);
	if (err != ESP_OK) {
		ESP_LOGE(TAG, "Send error, %d\n", err);
	}
#else
	host_serial_bus_write(s_host_device_handle, txbuff, wlen + ESP_PAYLOAD_HEADER_SIZE);
#endif

	free(txbuff);
}

/**
  * @brief  Send to slave via SPI
  * @param  iface_type -type of interface
  *         iface_num - interface number
  *         wbuffer - tx buffer
  *         wlen - size of wbuffer
  * @retval sendbuf - Tx buffer
  */
esp_err_t send_to_slave(uint8_t iface_type, uint8_t iface_num,
		uint8_t * wbuffer, uint16_t wlen)
{
	interface_buffer_handle_t buf_handle = {0};

	if (!wbuffer || !wlen || (wlen > MAX_PAYLOAD_SIZE)) {
		printf("write fail: buff(%p) 0? OR (0<len(%u)<=max_poss_len(%u))?\n\r",
				wbuffer, wlen, MAX_PAYLOAD_SIZE);
		if(wbuffer) {
			free(wbuffer);
			wbuffer = NULL;
		}
		return ESP_FAIL;
	}
	memset(&buf_handle, 0, sizeof(buf_handle));

	buf_handle.if_type = iface_type;
	buf_handle.if_num = iface_num;
	buf_handle.payload_len = wlen;
	buf_handle.payload = wbuffer;
	buf_handle.priv_buffer_handle = wbuffer;
	buf_handle.free_buf_handle = free;

	if (pdTRUE != xQueueSend(to_slave_queue, &buf_handle, portMAX_DELAY)) {
		printf("Failed to send buffer to_slave_queue\n\r");
		if(wbuffer) {
			free(wbuffer);
			wbuffer = NULL;
		}
		return ESP_FAIL;
	}

	check_and_execute_spi_transaction(wlen);

	return ESP_OK;
}

#ifdef CONFIG_TRANSMIT_USE_SDSPI
static void sdspi_recv_task(void* pvParameters)
{
    esp_err_t ret;
    uint8_t flag = 1;
    uint32_t intr_raw;

	interface_buffer_handle_t buf_handle = {0};
	struct  esp_payload_header *payload_header;
	uint16_t payload_len, offset;

    while (1) {

        if (flag) {
            ret = at_spi_wait_int(100);
        } else {
            ret = at_spi_wait_int(portMAX_DELAY);
        }

        if (ret == ESP_ERR_TIMEOUT) {
            flag = 0;
            continue;
        }

        assert(ret == ESP_OK);

        ret = at_sdspi_get_intr(&intr_raw);
        assert(ret == ESP_OK);

        ret = at_sdspi_clear_intr(intr_raw);
        assert(ret == ESP_OK);

        if (intr_raw & HOST_SLC0_RX_NEW_PACKET_INT_ST) {
            size_t size_read = READ_BUFFER_LEN;
            esp_err_t err = at_sdspi_get_packet(&context, esp_at_recvbuf, READ_BUFFER_LEN, &size_read);

            if (err == ESP_ERR_NOT_FOUND) {
                ESP_LOGE(TAG, "interrupt but no data can be read");
                break;
            } else if (err != ESP_OK && err != ESP_ERR_NOT_FINISHED) {
                ESP_LOGE(TAG, "rx packet error: %08X", err);
            }

            {
				/* create buffer rx handle, used for processing */
				payload_header = (struct esp_payload_header *) esp_at_recvbuf;

				/* Fetch length and offset from payload header */
				payload_len = le16toh(payload_header->len);
				offset = le16toh(payload_header->offset);

				buf_handle.priv_buffer_handle = esp_at_recvbuf;
				buf_handle.free_buf_handle = free;
				buf_handle.payload_len = payload_len;
				buf_handle.if_type     = payload_header->if_type;
				buf_handle.if_num      = payload_header->if_num;
				buf_handle.payload     = esp_at_recvbuf + offset;
				
				if (pdTRUE != xQueueSend(from_slave_queue,
							&buf_handle, portMAX_DELAY)) {
					printf("Failed to send buffer\n\r");
					break;
				}
            }

            memset(esp_at_recvbuf, '\0', sizeof(esp_at_recvbuf));
        }
    }
}
#else
static esp_err_t IRAM_ATTR recv_cb(host_serial_bus_handle_t device, host_recv_status_t recv_status, const void *buffer, size_t len)
{
    if (!buffer || !len) {
        return ESP_FAIL;
    }
	ESP_LOGD(TAG, "Host recv len %d", len);

	interface_buffer_handle_t buf_handle = {0};
	struct  esp_payload_header *payload_header;
	uint16_t payload_len, offset;

	/* create buffer rx handle, used for processing */
	payload_header = (struct esp_payload_header *) buffer;

	/* Fetch length and offset from payload header */
	payload_len = le16toh(payload_header->len);
	offset = le16toh(payload_header->offset);

	buf_handle.priv_buffer_handle = buffer;
	buf_handle.free_buf_handle = free;
	buf_handle.payload_len = payload_len;
	buf_handle.if_type     = payload_header->if_type;
	buf_handle.if_num      = payload_header->if_num;
	buf_handle.payload     = buffer + offset;
	
	if (pdTRUE != xQueueSend(from_slave_queue,
				&buf_handle, portMAX_DELAY)) {
		printf("Failed to send buffer\n\r");
	}
}
#endif

/** Local functions **/

/**
  * @brief  RX processing task
  * @param  argument: Not used
  * @retval None
  */
static void process_rx_task(void* pvParameters)
{
	esp_err_t ret = ESP_OK;
	interface_buffer_handle_t buf_handle = {0};
	uint8_t *payload = NULL;
	struct pbuf *buffer = NULL;
	struct esp_priv_event *event = NULL;
	struct esp_private *priv = NULL;
	uint8_t *serial_buf = NULL;

	while (1) {
		ret = xQueueReceive(from_slave_queue, &buf_handle, portMAX_DELAY);
		if (ret != pdTRUE) {
			continue;
		}

		/* point to payload */
		payload = buf_handle.payload;

		/* process received buffer for all possible interface types */
		if (buf_handle.if_type == ESP_SERIAL_IF) {

			serial_buf = (uint8_t *)malloc(buf_handle.payload_len);
			assert(serial_buf);

			memcpy(serial_buf, payload, buf_handle.payload_len);

			/* serial interface path */
			serial_rx_handler(buf_handle.if_num, serial_buf,
					buf_handle.payload_len);

		} else if((buf_handle.if_type == ESP_STA_IF) ||
				(buf_handle.if_type == ESP_AP_IF)) {
			priv = get_priv(buf_handle.if_type, buf_handle.if_num);

			if (priv) {
				buffer = (struct pbuf *)malloc(sizeof(struct pbuf));
				assert(buffer);

				buffer->len = buf_handle.payload_len;
				buffer->payload = malloc(buf_handle.payload_len);
				assert(buffer->payload);

				memcpy(buffer->payload, buf_handle.payload,
						buf_handle.payload_len);
				
				netdev_rx(priv->netdev, buffer);
			}

		} else if (buf_handle.if_type == ESP_PRIV_IF) {
			/* priv transaction received */

			event = (struct esp_priv_event *) (payload);
			if (event->event_type == ESP_PRIV_EVENT_INIT) {
				/* halt spi transactions for some time,
				 * this is one time delay, to give breathing
				 * time to slave before spi trans start */
				vTaskDelay(50000);
				if (sdspi_drv_evt_handler_fp) {
					sdspi_drv_evt_handler_fp(SDSPI_DRIVER_ACTIVE);
				}
			} else {
				/* User can re-use this type of transaction */
			}
		}

		/* Free buffer handle */
		/* When buffer offloaded to other module, that module is
		 * responsible for freeing buffer. In case not offloaded or
		 * failed to offload, buffer should be freed here.
		 */
/****************************************************/ //debug 
		// if (buf_handle.free_buf_handle) {
		// 	buf_handle.free_buf_handle(buf_handle.priv_buffer_handle);
		// }
/****************************************************/
	}
}


/**
  * @brief  Next TX buffer in SPI transaction
  * @param  argument: Not used
  * @retval sendbuf - Tx buffer
  */
static uint8_t * get_tx_buffer(uint8_t *is_valid_tx_buf)
{
	struct  esp_payload_header *payload_header;
	uint8_t *sendbuf = NULL;
	uint8_t *payload = NULL;
	uint16_t len = 0;
	interface_buffer_handle_t buf_handle = {0};

	*is_valid_tx_buf = 0;

	/* Check if higher layers have anything to transmit, non blocking.
	 * If nothing is expected to send, queue receive will fail.
	 * In that case only payload header with zero payload
	 * length would be transmitted.
	 */
	if (pdTRUE == xQueueReceive(to_slave_queue, &buf_handle, 0)) {
		len = buf_handle.payload_len;
	}

	if (len) {

		sendbuf = (uint8_t *) malloc(MAX_SPI_BUFFER_SIZE);
		if (!sendbuf) {
			printf("malloc failed\n\r");
			goto done;
		}

		memset(sendbuf, 0, MAX_SPI_BUFFER_SIZE);

		*is_valid_tx_buf = 1;

		/* Form Tx header */
		payload_header = (struct esp_payload_header *) sendbuf;
		payload = sendbuf + sizeof(struct esp_payload_header);
		payload_header->len     = htole16(len);
		payload_header->offset  = htole16(sizeof(struct esp_payload_header));
		payload_header->if_type = buf_handle.if_type;
		payload_header->if_num  = buf_handle.if_num;
		payload_header->reserved1 = 0;

		memcpy(payload, buf_handle.payload, min(len, MAX_PAYLOAD_SIZE));
	}

done:
	/* free allocated buffer */
	if (buf_handle.free_buf_handle)
		buf_handle.free_buf_handle(buf_handle.priv_buffer_handle);

	return sendbuf;
}
